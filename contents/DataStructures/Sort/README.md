# 정렬(Sorting)

![IMAGES](../images/sort.JPG)

# 선택 정렬(Selection Sort)

Point. 최솟값을 찾아 정렬되지 않은 가장 앞에 존재하는 원소와 교체(swap)하는 알고리즘 : `1회전마다 최솟값을 앞으로 보내는 알고리즘`

- __제자리 정렬(in-place sorting) 알고리즘의 하나__
  - 입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법
- __해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘__
  - 첫 번째 순서에는 첫 번째 위치에 가장 최솟값을 넣는다.
  - 두 번째 순서에는 두 번째 위치에 남은 값중에서의 최솟값을 넣는다.
- __과정 설명__
  1. 주어진 배열 중에서 최솟값을 찾는다.
  2. 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass))
  3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
  4. 하나의 원소만 남을 때까지 위의 과정을 반복한다.
- __구체적인 개념__
  - 선택 정렬은 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 `가장 작은 값(최솟값)`을 찾아 첫 번째에 놓고, 두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.

## 구현

```java
// 정렬 코드의 가장 큰 특징 중 하나가 교체(swap) 코드를 잘 기억해야 함
// 선택정렬 : 최솟값을 찾아서 정렬 되지 않은 가장 앞의 인덱스랑 교체
public int[] solution(int[] arr) {
    for(int i=0; i<arr.length-1; i++) {
        int tmp = arr[i];
        for(int k=i+1; k<arr.length; k++) {
            if(tmp > arr[k]) {
                tmp = arr[k];
                arr[k] = arr[i];
                arr[i] = tmp;
            }
        }
    }
    return arr;
}
```

# 버블 정렬(Bubble Sort)

Point. 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘 : `1회전 마다 최댓값을 맨 뒤로 보내는 알고리즘`

- __서로 인접한(adjacent) 두 원소를 검사하여 정렬하는 알고리즘__
   - 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 교환한다.
   - 선택 정렬과 기본 개념이 유사하다.
- __구체적인 개념__
  - 버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
  - `1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동`하므로 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

## 구현

```java
public int[] solution(int[] arr) {
    // arr.length = n
    for(int i=0; i<arr.length-1; i++) { // 바깥 반복문은 n-1 회 만큼 반복
        for(int k=0; k<arr.length-i-1; k++) { // 1회전하면 마지막 원소는 정렬이 되었으므로 n-i-1
            if(arr[k] > arr[k+1]) {
                int tmp = arr[k];
                arr[k] = arr[k+1];
                arr[k+1] = tmp;
            }
        }
    }
    return arr;
}
```

# 삽입 정렬(Insertion Sort)

Point. 첫 인덱스 값은 이미 정렬된 것으로 보고, 2 번째 자료 부터 정렬을 시작한다. : `1회전 마다 자기 앞에 있는 자료들과 비교하는 알고리즘`

- 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교 하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
- 매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.
- __구체적인 개념__
  - 삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.
  - 즉, 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다. 자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킨다.
  - `처음 Key 값은 두 번재 자료부터 시작한다.`

## 특징

- __장점__
  - 안정적인 정렬 방법
  - 레코드의 수가 적을 수록 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.
  - 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.
- __단점__
  - 비교적 많은 레코드들의 이동을 포함한다.
  - 레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다.

## 구현

```java
public int[] solution(int[] arr) {
  int key;

  // 인덱스 0은 이미 정렬된 것으로 볼 수 있다.
  for(int i=1; i<arr.length; i++) { // 바깥 반복문은 삽입될 숫자들에 대한 반복문 (즉, 첫 인덱스를 제외한 n-1 만큼 반복)
      key = arr[i]; // 현재 삽입될 숫자인 i번째 정수를 key 변수로 복사

      // 현재 정렬된 배열은 i-1까지이므로 i-1번째부터 역순으로 조사한다.
      // k 값은 음수가 아니어야 되고
      // key 값보다 정렬된 배열에 있는 값이 크면 k 번째를 k+1 번째로 이동
      for(int k=i-1; k>=0; k--) { // 내부 반복문은 자기 바로 앞에 존재하는 자료들과 비교
          if(arr[k] > key) {
              key = arr[k+1];
              arr[k+1] = arr[k];
              arr[k] = key;
          }
      }
  }
  return arr;
}
```

## Reference

> https://gmlwjd9405.github.io
